# Manifest for looking up compiled asset paths
#
# The manifest reads the manifest.json file produced by webpack/rspack during
# compilation and provides methods to look up the compiled (digested) paths for
# source files.
class Shakapacker::Manifest
  # Raised when an asset cannot be found in the manifest
  class MissingEntryError < StandardError
  end

  # Creates a new manifest instance
  def initialize: (Instance instance) -> void

  # Reloads the manifest data from disk
  def refresh: () -> Hash[String, untyped]

  # Looks up an entry point with all its chunks (split code)
  def lookup_pack_with_chunks: (String name, ?Hash[Symbol, untyped] pack_type) -> Array[String]?

  # Like lookup_pack_with_chunks, but raises an error if not found
  def lookup_pack_with_chunks!: (String name, ?Hash[Symbol, untyped] pack_type) -> Array[String]

  # Looks up the compiled path for a given asset
  def lookup: (String name, ?Hash[Symbol, untyped] pack_type) -> String?

  # Like lookup, but raises an error if not found
  def lookup!: (String name, ?Hash[Symbol, untyped] pack_type) -> String

  # Returns the configuration object
  def config: () -> Configuration

  # Returns the compiler instance
  def compiler: () -> Compiler

  # Returns the dev server instance
  def dev_server: () -> DevServer

  private

  def compiling?: () -> bool

  def compile: () -> bool

  def data: () -> Hash[String, untyped]

  def load: () -> Hash[String, untyped]

  def find: (String key) -> (String | Hash[String, untyped] | nil)

  def handle_missing_entry: (String name, Hash[Symbol, untyped] pack_type) -> void

  def manifest_empty_error: (bool manifest_exists) -> String

  def missing_file_from_manifest_error: (String bundle_name) -> String

  def full_pack_name: (String name, Symbol? pack_type) -> String

  def manifest_type: (Symbol? type) -> String

  def manifest_name: (String name, String manifest_type) -> String
end
